#!/usr/bin/perl -w
use strict;
use warnings;
use diagnostics;
use File::Basename;
use File::Copy;

use Shell qw(cp cat ls find diff mkdir svn date rm);

#my $time_stamp = gmtime();
my $time_stamp = localtime();

my $def_makefile_common_header .= <<___;
################################################################
# This file is auto generated by tool: Local-build-refine.pl.
# You can modify it manually for customization.
#
# $time_stamp
################################################################

___


my $def_makefile_common_body .= <<___;

# CPPFLAGS += -I\$(path_elf_parser)/include
# DEP_MODULES += \$(path_sqlite_amal)

# OTHER_LDFLAGS += -L\$(path_sqlite_build)/.libs -lsqlite3
# OTHER_LDFLAGS += -L\$(path_ace_lib) -lACE
# OTHER_LDFLAGS += -lpthread  -ldl -lrt
# OTHER_LDFLAGS += -L\$(path_openssl_build)/lib -lssl -lcrypto
# OTHER_LDFLAGS += -L\$(path_zlib_build)/lib  -lz
# OTHER_LDFLAGS += -L\$(path_libconfig_build)/.libs -lconfig++

include \$(HOMESYS_ROOT)/kkbuild/common.mk
___

my $sh = Shell->new;

################
# for debug array.
################################################################
sub print_array {
  foreach (@_) {
    print $_, "\n";
  }
}

################
# to check whether the code has 'main' func definition.
# $1: local source file name
################################################################
sub has_main_entry {
  my $file = shift;
  chomp $file;
  my $contents = join('', $sh->cat("$file")); # there should be a better way to do this.
  # print $contents;
  if ($contents =~ /^\s*(\bint\b|\bvoid\b|)\s*(main|ACE_TMAIN)\s*\(.*?\)/m) {
    print "Note: $file have main func definition \n";
    return 1;
  }

  # if ($contents =~ /\n^\s*(\bint\b|\bvoid\b|)\s*(main|ACE_TMAIN)\s*\(.*?\)/m ||
  #     $contents =~ /\n^\s*(main|ACE_TMAIN)\s*\(.*?\)/m) { # refex multiline match
  #     print "Note: $file have main func definition \n";
  #     return 1;
  # }

  return 0;
}

################
# generate_commands($src_file, $dst_file);
# return: command string.
################################################################
sub generate_commands {
  my $srcfile = shift;
  my $dstdir = shift;
  my $cmd_prefix = sprintf("mv %18s%18s", $srcfile, $dstdir);
  return $cmd_prefix;
}

################
# to check whether local svn file is up to date.
# died if not!
################################################################
sub assert_svn_uptodate {
  my @svn_status = $sh->svn("st ");
  if (@svn_status) {
    print_array @svn_status;
    die "snv is not up to date please do check!";
  }
}

################
# exec_commands(@command_array);
################################################################
sub exec_commands {
  foreach (@_) {
    system($_) == 0 || die "system($_) failed!!";
  }
}

sub do_nothing_exit {
  print "nothing to do, exit 0\n";
  # if ($backup_name ne "" && -f $backup_name) {
  #   # print "delete $backup_name \n";
  #   unlink $backup_name;
  # }
  exit(0);
}

sub backup_local_makefile {
  if (-f "Makefile") {
    my $backup_name = $sh->date(" +%Y%m%d_%S");
    chop $backup_name;
    $backup_name = "org." . $backup_name . ".mk";
    copy("Makefile","$backup_name") or die "Copy failed: $!";
    print "backup old Makefile to $backup_name \n";
  }
}

my $src_dir = "src";
my $inc_dir = "include";

my @src_files = glob "*.c *.cpp *.cxx *.cc";
my @head_files = glob "*.h *.hpp";

if (!@src_files && !@head_files) {
  die "no source files here!!";
}

#print_array @src_files;

my @commands;
my @main_entry_files; # list of source files that contains the 'main()' entry function
my @common_src_files; # list of source files that should be moved to ./src

foreach (@src_files, @head_files) {
  my $dst_dir = m[\.cp{0,2}$] ? "$src_dir" : "$inc_dir";
  my $cmd = generate_commands($_, $dst_dir);
  if (!has_main_entry($_)) {
    push @commands, $cmd;
    push @common_src_files, $_;
  } else {
    push @main_entry_files, $_;
  }
}

splice @commands, 0, 0, "mkdir -p $inc_dir" unless @head_files <= 0;
splice @commands, 0, 0, "mkdir -p $src_dir" unless @common_src_files <= 0;


# assert_svn_uptodate;
# $sh->mkdir("-p $src_dir") unless @src_files <= 0;
# $sh->mkdir("-p $inc_dir") unless @head_files <= 0;
# $sh->svn("add  $src_dir $inc_dir $lib_dir") || die "lyk svn add error!!!";

################################################################
# parse @main_entry_files to get the 'EXENAME'
################
my $exe_name_prefix = "EXENAME :=";
my $exe_name_str = $exe_name_prefix;
if (@main_entry_files > 0) {
  foreach (@main_entry_files) {
    #        print "== $_ \n";
    my $basename = basename $_;
    (my $filename = $basename) =~ s/\.[^.]+$//;
    if ($filename =~ /^test/ ||
        $filename =~ /^t_/ ) {
      #            print "$filename is a unit test file \n";
      next;
    }
    $exe_name_str .= " $filename";
    print "exe_name_str = $exe_name_str\n";
  }
}

################################################################
# start to parsing the CODE_TYPE
################
my $code_type = "CODE_TYPE := ";
my $code_type_var = "";
foreach (@src_files) {
  if ($_ =~ /\w+\.c$/) {
    if ($code_type_var eq "") {
      $code_type_var = "c";
    } elsif ($code_type_var eq "cpp") {
      print "$_ is a C source file, but there exists CPP source file \n";
      die "C and CPP can not co-exist within one module!";
    } elsif ($code_type_var eq "c") {
      #            print "C continue: $_ \n";
    } else {
      die "illegal code_type_var:$code_type_var";
    }
  } elsif ($_ =~ /^\w+\.cpp$/ ||
           $_ =~ /^\w+\.cxx$/ ||
           $_ =~ /^\w+\.cc$/ ) {
    if ($code_type_var eq "") {
      $code_type_var = "cpp";
    } elsif ($code_type_var eq "c") {
      print "$_ is a CPP source file, but there exists C source file \n";
      die "C and CPP can not co-exist within one module!";
    } elsif ($code_type_var eq "cpp") {
      #            print "cpp continue: $_ \n";
    } else {
      die "illegal code_type_var:$code_type_var";
    }
  } else {
    die "illegal source file:$_";
  }
}
$code_type = $code_type . $code_type_var;

if (@commands > 0) {
  print "\n";
  print "================ I will do executing the following commands ================" . "\n";
  print_array @commands;
  print "============================================================================" . "\n";
  print "\n";
  exec_commands @commands;
} else {
  print "Note: No command to execute \n";
}

my $lmk_exename = "";
my $lmk_libname = "";

sub check_local_makefile {
  open(LMKFile, "< Makefile") or die "can not open local Makefile";

  while (<LMKFile>) {
    chop;
    if ($_ =~ /^\s*#/) {
      next;
    }
    if ($_ =~ /^\s*EXENAME\s*:?=\s*\w+/) {
      print "local: $_ \n";
      $lmk_exename = $_;
      next;
    }
    if ($_ =~ /^\s*LIBNAME\s*:?=\s*\w+/) {
      print "local: $_ \n";
      $lmk_libname = $_;
      next;
    }
    if ($lmk_exename ne "" || $lmk_libname ne "") {
      last;
    }
  }
  close(LMKFile);

  if ($lmk_exename eq "" && $lmk_libname eq "") {
    print "exename and libname are both empty \n";
    return 0;
  }
  # print "lmk_exename:$lmk_exename, lmk_libname:$lmk_libname \n";
  return 1;
}

my $using_local_makefile = 0;
if (-f "Makefile" && check_local_makefile()) {
  print "using local Makefile \n";
  $using_local_makefile = 1;
}

my @makefile_lines;
my $using_parsed_exename = 0;
my $makefile_code = "";
my $do_nothing = 0;
if (!$using_local_makefile) {
  ################################################################
  # start to parsing the LIBNAME
  ################
  my $lib_module_name_prefix = "LIBNAME := ";
  my $lib_module_name = $lib_module_name_prefix;
  if ($exe_name_str eq $exe_name_prefix) { # only if the exe_name_str is not ok, we use LIBNAME
    my $name_l = basename $ENV{PWD};
    my $name_h = basename(dirname $ENV{PWD});
    if ($name_h eq "/") { # the case like '/test', just under the root dir
      $lib_module_name .= "lib" . $name_l . ".a";
    }
    else {
      #        print "name_l:$name_l, name_h:$name_h \n\n" ;
      $lib_module_name .= "lib" . $name_h . "_" . $name_l . ".a";
    }
    print "$lib_module_name \n";
    $makefile_code .= "$lib_module_name\n";
  }
  else {
    $makefile_code .= "$exe_name_str\n";
  }
  $makefile_code .= "$code_type\n";
}
else {                        # local Makefile is already exists
  if ($exe_name_str eq $exe_name_prefix) {
    print "using local Makefile but contains no executable target, so exit here!";
    do_nothing_exit;
  }
  open(INFile, "< Makefile") or die "can not open Makefile";
  while (<INFile>) {
    chomp;
    if ($_ =~ /\s*EXENAME\s*:?=\s*\w+/) {
      if ($_ eq $exe_name_str) {
        print "$_, $exe_name_str \n";
        $do_nothing = 1;
        last;
      }
      else {
        print "** $_\n";
        push @makefile_lines, $exe_name_str;
      }
      next;
    }
    push @makefile_lines, $_;
  }
  close INFile;
}

# print "do_nothing:$do_nothing \n";
do_nothing_exit unless $do_nothing == 0;

backup_local_makefile();

open(OUTFILE, ">Makefile") || die("Cannot open Makefile files\n");
if ($makefile_code ne "") {
  print OUTFILE $def_makefile_common_header;
  print OUTFILE $makefile_code;
  print OUTFILE $def_makefile_common_body;
}
else {
  foreach (@makefile_lines) {
    print OUTFILE "$_\n";
  }
}
close OUTFILE;


print
  "################################################################" . "\n",
  "building sys conversion ok, please modify the generated example"  . "\n",
  "makefile to meet your needs, you can refer to apps/vsp/Makefile"  . "\n",
  "################################################################" . "\n";
print "\n";


print "$code_type\n";

