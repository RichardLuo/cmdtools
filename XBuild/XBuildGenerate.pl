#!/usr/bin/perl -w
use strict;
use warnings;
use diagnostics;
use File::Basename;
use XBuild::Utils;

use Shell qw(cp cat ls find diff mkdir svn date rm);

#my $time_stamp = gmtime();
my $time_stamp = localtime();

my $def_makefile_common_header .= <<___;
################################################################
# This file is auto generated by cmd: XBuildGenerate.pl
# You can modify it manually for customization.
#
# $time_stamp
################################################################

___


my $def_makefile_common_body .= <<___;

# CPPFLAGS += -I\$(path_elf_parser)/include
# DEP_MODULES += \$(path_sqlite_amal)

# OTHER_LDFLAGS += -L\$(path_sqlite_build)/.libs -lsqlite3
# OTHER_LDFLAGS += -L\$(path_ace_lib) -lACE
# OTHER_LDFLAGS += -lpthread  -ldl -lrt
# OTHER_LDFLAGS += -L\$(path_openssl_build)/lib -lssl -lcrypto
# OTHER_LDFLAGS += -L\$(path_zlib_build)/lib  -lz
# OTHER_LDFLAGS += -L\$(path_libconfig_build)/.libs -lconfig++

include \$(HOMESYS_ROOT)/kkbuild/common.mk
___

my $sh = Shell->new;


################
# generate_move_file_command($src_file, $dst_file);
# return: command string.
################################################################
sub generate_move_file_command {
  my ($src_file, $dst_dir) = @_;
  return sprintf("mv %18s%18s", $src_file, $dst_dir);
}

# ################
# # to check whether local svn file is up to date.
# # died if not!
# ################################################################
# sub assert_svn_uptodate {
#   my @svn_status = $sh->svn("st ");
#   if (@svn_status) {
#     print_array @svn_status;
#     die "snv is not up to date please do check!";
#   }
# }


my $src_dir = "src";
my $inc_dir = "include";

my @src_files = glob "*.c *.cpp *.cxx *.cc";
my @head_files = glob "*.h *.hpp";

if (!@src_files && !@head_files) {
  die "no source files here!!";
}

#print_array @src_files;

my @commands;
my @main_entry_files; # list of source files that contains the 'main()' entry function
my @common_src_files; # list of source files that should be moved to ./src

foreach (@src_files, @head_files) {
  my $dst_dir = m[\.cp{0,2}$] ? "$src_dir" : "$inc_dir";
  my $cmd = generate_move_file_command($_, $dst_dir);
  if (!Utils::has_main_entry($_)) {
    push @commands, $cmd;
    push @common_src_files, $_;
  } else {
    push @main_entry_files, $_;
  }
}

splice @commands, 0, 0, "mkdir $inc_dir" unless (@head_files <= 0) || (-d $inc_dir);
splice @commands, 0, 0, "mkdir $src_dir" unless (@common_src_files <= 0) || (-d $src_dir);

# assert_svn_uptodate;
# $sh->mkdir("-p $src_dir") unless @src_files <= 0;
# $sh->mkdir("-p $inc_dir") unless @head_files <= 0;
# $sh->svn("add  $src_dir $inc_dir $lib_dir") || die "lyk svn add error!!!";

################################################################
# parse @main_entry_files to get the 'EXENAME'
################
my $exe_name_prefix = "EXENAME :=";
my $exe_name_str = $exe_name_prefix;
if (@main_entry_files > 0) {
  foreach (@main_entry_files) {
    #        print "== $_ \n";
    my $basename = basename $_;
    (my $filename = $basename) =~ s/\.[^.]+$//;
    if ($filename =~ /^test/ ||
        $filename =~ /^t_/ ) {
      #            print "$filename is a unit test file \n";
      next;
    }
    $exe_name_str .= " $filename";
    print "exe_name_str = $exe_name_str\n";
  }
}

################################################################
# start to parsing the CODE_TYPE
################
my $code_type = "CODE_TYPE := ";
my $code_type_var = "";
foreach (@src_files) {
  if ($_ =~ /\w+\.c$/) {
    if ($code_type_var eq "") {
      $code_type_var = "c";
    } elsif ($code_type_var eq "cpp") {
      print "$_ is a C source file, but there exists CPP source file \n";
      die "C and CPP can not co-exist within one module!";
    } elsif ($code_type_var eq "c") {
      #            print "C continue: $_ \n";
    } else {
      die "illegal code_type_var:$code_type_var";
    }
  } elsif ($_ =~ /^\w+\.cpp$/ ||
           $_ =~ /^\w+\.cxx$/ ||
           $_ =~ /^\w+\.cc$/ ) {
    if ($code_type_var eq "") {
      $code_type_var = "cpp";
    } elsif ($code_type_var eq "c") {
      print "$_ is a CPP source file, but there exists C source file \n";
      die "C and CPP can not co-exist within one module!";
    } elsif ($code_type_var eq "cpp") {
      #            print "cpp continue: $_ \n";
    } else {
      die "illegal code_type_var:$code_type_var";
    }
  } else {
    die "illegal source file:$_";
  }
}
$code_type = $code_type . $code_type_var;

if (@commands > 0) {
  print "\n";
  print "================ I will do executing the following commands ================" . "\n";
  Utils::print_array @commands;
  print "============================================================================" . "\n";
  print "\n";
  Utils::exec_commands @commands;
} else {
  print "Note: No command to execute \n";
}

my $lmk_exename = "";
my $lmk_libname = "";

sub check_local_makefile {
  open(LMKFile, "< Makefile") or die "can not open local Makefile";

  while (<LMKFile>) {
    chop;
    if ($_ =~ /^\s*#/) {
      next;
    }
    if ($_ =~ /^\s*EXENAME\s*:?=\s*\w+/) {
      print "local: $_ \n";
      $lmk_exename = $_;
      next;
    }
    if ($_ =~ /^\s*LIBNAME\s*:?=\s*\w+/) {
      print "local: $_ \n";
      $lmk_libname = $_;
      next;
    }
    if ($lmk_exename ne "" || $lmk_libname ne "") {
      last;
    }
  }
  close(LMKFile);

  if ($lmk_exename eq "" && $lmk_libname eq "") {
    print "exename and libname are both empty \n";
    return 0;
  }
  # print "lmk_exename:$lmk_exename, lmk_libname:$lmk_libname \n";
  return 1;
}

my $using_local_makefile = 0;
if (-f "Makefile" && check_local_makefile()) {
  print "using local Makefile \n";
  $using_local_makefile = 1;
}


my @makefile_lines;
my $using_parsed_exename = 0;
my $makefile_code = "";
my $do_nothing = 0;
if (!$using_local_makefile) {
  ################################################################
  # start to parsing the LIBNAME
  ################
  if ($exe_name_str eq $exe_name_prefix) { # only if the exe_name_str is not ok, we use LIBNAME
    $makefile_code .= "LIBNAME := lib" . Utils::get_base_local_module_name($ENV{PWD}) . ".a";
  }
  else {
    $makefile_code .= "$exe_name_str\n";
  }
  $makefile_code .= "$code_type\n";
}
else {                        # local Makefile is already exists
  if ($exe_name_str eq $exe_name_prefix) {
    print "using local Makefile but contains no executable target, so exit here!\n";
    Utils::do_nothing_exit;
  }
  open(INFile, "< Makefile") or die "can not open Makefile";
  my $lmk_contain_exename = 0;
  while (<INFile>) {
    chomp;
    if ($_ =~ /\s*EXENAME\s*:?=\s*\w+/) {
      $lmk_contain_exename = 1;
      if ($_ eq $exe_name_str) {
        print "$_, $exe_name_str \n";
        $do_nothing = 1;
        last;
      }
      else {
        print "** $_\n";
        push @makefile_lines, $exe_name_str;
      }
      next;
    }

    if ($_ =~ /\s*LIBNAME\s*:?=\s*\w+/) {
      if (!$lmk_contain_exename) {
        push @makefile_lines, $exe_name_str;
      }
    }

    push @makefile_lines, $_;
  }
  close INFile;
}

# print "do_nothing:$do_nothing \n";
Utils::do_nothing_exit unless $do_nothing == 0;

Utils::backup_file("Makefile");

open(OUTFILE, ">Makefile") || die("Cannot open Makefile files\n");
if ($makefile_code ne "") {
  print OUTFILE $def_makefile_common_header;
  print OUTFILE $makefile_code;
  print OUTFILE $def_makefile_common_body;
}
else {
  foreach (@makefile_lines) {
    print OUTFILE "$_\n";
  }
}
close OUTFILE;


print
  "################################################################" . "\n" .
  "                               OK                               " . "\n" .
  "################################################################" . "\n" .
  "\n";

print "$code_type\n";

